{
  "name": "geolib",
  "homepage": "http://github.com/manuelbieh/Geolib",
  "author": {
    "name": "Manuel Bieh",
    "url": "http://www.manuelbieh.com/"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/manuelbieh/geolib.git"
  },
  "devDependencies": {
    "grunt": "~0.4",
    "grunt-cli": "*",
    "grunt-contrib-uglify": "~0.2",
    "grunt-contrib-concat": "~0.3",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-copy": "~0.4",
    "grunt-contrib-qunit": "~0.2.0",
    "grunt-text-replace": "~0.3.6",
    "grunt-contrib-jshint": "~0.6.2",
    "phantomjs": ">=1.8.0",
    "grunt-jslint": "~1.0.0",
    "time-grunt": "~0.3.1",
    "load-grunt-tasks": "~0.4.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/MIT"
    }
  ],
  "files": [
    "dist/geolib.js",
    "dist/geolib.elevation.js"
  ],
  "description": "Library to perform geo specific tasks",
  "keywords": [
    "geolocation",
    "geo",
    "distance",
    "geojson",
    "geospatial",
    "lbs",
    "location"
  ],
  "scripts": {
    "test": "grunt travis --verbose"
  },
  "version": "2.0.21",
  "main": "dist/geolib.js",
  "readme": "# Geolib v2.0.21\n[![Build Status](https://secure.travis-ci.org/manuelbieh/Geolib.png?branch=master)](http://travis-ci.org/manuelbieh/Geolib)\n\nLibrary to provide basic geospatial operations like distance calculation, conversion of decimal coordinates to sexagesimal and vice versa, etc.\n\n[View demo](http://www.manuel-bieh.de/publikationen/scripts/geolib/demo.html)\n\n<h2>Methods</h2>\n\n<h3>geolib.getDistance(object start, object end[, int accuracy, int precision])</h3>\n\nCalculates the distance between two geo coordinates\n\nTakes 2 or 4 arguments. First 2 arguments must be objects that each have latitude and longitude properties (e.g. `{latitude: 52.518611, longitude: 13.408056}`)Works with:. Coordinates can be in sexagesimal or decimal format. 3rd argument is accuracy (in meters). So a calculated distaWorks with:nce of 1248 meters with an accuracy of 100 is returned as `1200` (accuracy 10 = `1250` etc.). 4th argument is precision in sub-meters (1 is meter presicion, 2 is decimeters, 3 is centimeters, etc).\n\nReturn value is always an float and represents the distance in meters.\n\n<h4>Examples</h4>\n\n<pre>geolib.getDistance(\n    {latitude: 51.5103, longitude: 7.49347},\n    {latitude: \"51° 31' N\", longitude: \"7° 28' E\"}\n);\ngeolib.getDistance(\n    {latitude: 51.5103, longitude: 7.49347},\n    {latitude: \"51° 31' N\", longitude: \"7° 28' E\"}\n);\n\n// Working with W3C Geolocation API\nnavigator.geolocation.getCurrentPosition(\n    function(position) {\n        alert('You are ' + geolib.getDistance(position.coords, {\n            latitude: 51.525,\n            longitude: 7.4575\n        }) + ' meters away from 51.525, 7.4575');\n    },\n    function() {\n        alert('Position could not be determined.')\n    },\n    {\n        enableHighAccuracy: true\n    }\n);\n</pre>\n\n<h3>geolib.getCenter(array coords)</h3>\n\nCalculates the geographical center of all points in a collection of geo coordinates\n\nTakes an object or array of coordinates and calculates the center of it.\n\nReturns an object: `{\"latitude\": centerLat, \"longitude\": centerLng}`\n\n<h4>Examples</h4>\n\n<pre>var spots = {\n    \"Brandenburg Gate, Berlin\": {latitude: 52.516272, longitude: 13.377722},\n    \"Dortmund U-Tower\": {latitude: 51.515, longitude: 7.453619},\n    \"London Eye\": {latitude: 51.503333, longitude: -0.119722},\n    \"Kremlin, Moscow\": {latitude: 55.751667, longitude: 37.617778},\n    \"Eiffel Tower, Paris\": {latitude: 48.8583, longitude: 2.2945},\n    \"Riksdag building, Stockholm\": {latitude: 59.3275, longitude: 18.0675},\n    \"Royal Palace, Oslo\": {latitude: 59.916911, longitude: 10.727567}\n}\n\ngeolib.getCenter(spots);\n\ngeolib.getCenter([\n    {latitude: 52.516272, longitude: 13.377722},\n    {latitude: 51.515, longitude: 7.453619},\n    {latitude: 51.503333, longitude: -0.119722}\n]);\n</pre>\n\n<h3>geolib.getCenterOfBounds(array coords)</h3>\n\nCalculates the center of the bounds of geo coordinates.\n\nTakes an array of coordinates, calculate the border of those, and gives back\nthe center of that rectangle.\n\nOn polygons like political borders (eg. states), this may gives a closer\nresult to human expectation, than `getCenter`, because that function can be\ndisturbed by uneven distribution of point in different sides.\n\nImagine the US state Oklahoma: `getCenter` on that gives a southern\npoint, because the southern border contains a lot more nodes, than the others.\n\nReturns an object: `{\"latitude\": centerLat, \"longitude\": centerLng}`\n\n<h3>geolib.isPointInside(object latlng, array polygon)</h3>\n\nChecks whether a point is inside of a polygon or not.\nNote: the polygon coords must be in correct order!\n\nReturns true or false\n\n<h4>Example</h4>\n\n<pre>\ngeolib.isPointInside(\n    {latitude: 51.5125, longitude: 7.485},\n    [\n        {latitude: 51.50, longitude: 7.40},\n        {latitude: 51.555, longitude: 7.40},\n        {latitude: 51.555, longitude: 7.625},\n        {latitude: 51.5125, longitude: 7.625}\n    ]\n); // -> true</pre>\n\n<h3>geolib.isPointInCircle(object latlng, object center, integer radius)</h3>\n\nSimilar to is point inside: checks whether a point is inside of a circle or not.\n\nReturns true or false\n\n<h4>Example</h4>\n\n<pre>// checks if 51.525, 7.4575 is within a radius of 5km from 51.5175, 7.4678\ngeolib.isPointInCircle(\n    {latitude: 51.525, longitude: 7.4575},\n    {latitude: 51.5175, longitude: 7.4678},\n    5000\n);</pre>\n\n<h3>geolib.orderByDistance(object latlng, mixed coords)</h3>\n\nSorts an object or array of coords by distance from a reference coordinate\n\nReturns a sorted array [{latitude: x, longitude: y, distance: z, key: property}]\n\n<h4>Examples</h4>\n\n<pre>\n// coords array\ngeolib.orderByDistance({latitude: 51.515, longitude: 7.453619}, [\n    {latitude: 52.516272, longitude: 13.377722},\n    {latitude: 51.518, longitude: 7.45425},\n    {latitude: 51.503333, longitude: -0.119722}\n]);\n\n// coords object\ngeolib.orderByDistance({latitude: 51.515, longitude: 7.453619}, {\n    a: {latitude: 52.516272, longitude: 13.377722},\n    b: {latitude: 51.518, longitude: 7.45425},\n    c: {latitude: 51.503333, longitude: -0.119722}\n});\n</pre>\n\n<h3>geolib.findNearest(object latlng, mixed coords[[, int offset], int limit])</h3>\n\nFinds the nearest coordinate to a reference coordinate.\n\n<h4>Examples</h4>\n\n<pre>var spots = {\n    \"Brandenburg Gate, Berlin\": {latitude: 52.516272, longitude: 13.377722},\n    \"Dortmund U-Tower\": {latitude: 51.515, longitude: 7.453619},\n    \"London Eye\": {latitude: 51.503333, longitude: -0.119722},\n    \"Kremlin, Moscow\": {latitude: 55.751667, longitude: 37.617778},\n    \"Eiffel Tower, Paris\": {latitude: 48.8583, longitude: 2.2945},\n    \"Riksdag building, Stockholm\": {latitude: 59.3275, longitude: 18.0675},\n    \"Royal Palace, Oslo\": {latitude: 59.916911, longitude: 10.727567}\n}\n\n// in this case set offset to 1 otherwise the nearest point will always be your reference point\ngeolib.findNearest(spots['Dortmund U-Tower'], spots, 1)\n</pre>\n\n<h3>geolib.getPathLength(mixed coords)</h3>\n\nCalculates the length of a collection of coordinates\n\nReturns the length of the path in meters\n\n<h4>Example</h4>\n\n<pre>\n// Calculate distance from Berlin via Dortmund to London\ngeolib.getPathLength([\n    {latitude: 52.516272, longitude: 13.377722}, // Berlin\n    {latitude: 51.515, longitude: 7.453619}, // Dortmund\n    {latitude: 51.503333, longitude: -0.119722} // London\n]); // -> 945235</pre>\n\n<h3>geolib.getSpeed(coords, coords[, options])</h3>\n\nCalculates the speed between two points within a given time span.\n\nReturns the speed in <em>options.unit</em> (default is km/h).\n\n<h4>Example</h4>\n\n<pre>\ngeolib.getSpeed(\n    {lat: 51.567294, lng: 7.38896, time: 1360231200880},\n    {lat: 52.54944, lng: 13.468509, time: 1360245600880},\n    {unit: 'mph'}\n); // -> 66.9408 (mph)</pre>\n\n<h3>geolib.isPointInLine(object point, object start, object end</h3>\n\nCalculates if given point lies in a line formed by start and end.\n\nReturns true or false\n\n<h4>Examples</h4>\n\n<pre>var point1 = {latitude: 0.5, longitude: 0};\nvar point2 = {latitude: 0, longitude: 10};\nvar point3 = {latitude: 0, longitude: 15.5};\nvar start  = {latitude: 0, longitude: 0};\nvar end    = {latitude: 0, longitude: 15};\n\nvar isInLine1 = geolib.isPointInLine(point1, start, end) //-> false;\nvar isInLine2 = geolib.isPointInLine(point2, start, end) //-> true;\nvar isInLine3 = geolib.isPointInLine(point3, start, end) //-> false;\n</pre>\n\n<h3>geolib.convertUnit(string unit, float distance[, int round])</h3>\n\nConverts a given distance (in meters) to another unit.\n\n<h4>Parameters</h4>\n\n`unit` can be one of:\n\n- m (meter)\n- km (kilometers)\n- cm (centimeters)\n- mm (millimeters)\n- mi (miles)\n- sm (seamiles)\n- ft (foot)\n- in (inch)\n- yd (yards)\n\n`distance` distance to be converted (source must be in meter)\n\n`round` fractional digits\n\n<h4>Example</h4>\n\n`geolib.convertUnit('km', 14213, 2) // -> 14,21`\n\n<h3>geolib.sexagesimal2decimal(string coord)</h3>\n\nConverts a sexagesimal coordinate to decimal format\n\n<h4>Example</h4>\n\n`geolib.sexagesimal2decimal(\"51° 29' 46\\\" N\")`\n\n<h3>geolib.decimal2sexagesimal(float coord)</h3>\n\nConverts a decimal coordinate to sexagesimal format\n\n<h4>Example</h4>\n\n`geolib.decimal2sexagesimal(51.49611111); // -> 51° 29' 46.00`\n\n<h3>geolib.latitude(object latlng)</h3>\n<h3>geolib.longitude(object latlng)</h3>\n<h3>geolib.elevation(object latlng)</h3>\n\nReturns the latitude/longitude/elevation for a given point and converts it to decimal.\n\nWorks with:\n- longitude: `longitude`, `lng`, `lon`, 0 (GeoJSON array)\n- latitude: `latitude`, `lat`, 1 (GeoJSON array)\n- elevation: `elevation`, `elev`, `alt`, `altitude`, 2 (GeoJSON array)\n\n<h4>Examples</h4>\n\n`geolib.latitude({lat: 51.49611, lng: 7.38896}); // -> 51.49611`\n`geolib.longitude({lat: 51.49611, lng: 7.38896}); // -> 7.38896`\n\n<h3>geolib.useDecimal(mixed latlng)</h3>\n\nChecks if a coordinate is already in decimal format and, if not, converts it to\n\n<h4>Example</h4>\n\n<pre>geolib.useDecimal(\"51° 29' 46\\\" N\"); // -> 51.59611111\ngeolib.useDecimal(51.59611111) // -> 51.59611111</pre>\n\n<h3>geolib.computeDestinationPoint(start, distance, bearing, radius(optional))</h3>\n\nComputes the destination point given an initial point, a distance and a bearing\n\nIf no radius is given it defaults to the mean earth radius of 6371000 meter.\n\nReturns an object: `{\"latitude\": destLat, \"longitude\": destLng}`\n\n(Attention: this formula is not *100%* accurate (but very close though))\n\n<h4>Example</h4>\n\n<pre>var initialPoint = {lat: 51.516272, lon: 0.45425}\nvar dist = 1234;\nvar bearing = 45;\n\ngeolib.computeDestinationPoint(initialPoint.lat, initialPoint.lon, dist, bearing);\n// -> {\"latitude\":51.52411853234181,\"longitude\":0.4668623365950795}\n</pre>\n\n<h2>Changelog</h2>\n<h3>v2.0.0+beta1</h3>\n- Dropped support for IE6, IE7, IE8\n- Added new methods `geolib.latitude()`, `geolib.longitude()`, `geolib.elevation()` to get latitude, longitude or elevation of points. Will be converted to decimal format automatically\n- Added new method `geolib.extend()` to extend geolib object\n- Added support for GeoJSON format (`[lon, lat, elev]`)\n- Added property `geolib.version` to query the currently used version\n- Moved `geolib.elevation` to an optional module (`geolib.elevation.js`)\n- Using `Object.create(Geolib.prototype)` instead of object literal `{}`\n- New folder structure: compiled `geolib.js` can now be found in `dist/` instead of root dir\n- Improved Grunt build task\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/manuelbieh/geolib/issues"
  },
  "_id": "geolib@2.0.21",
  "dist": {
    "shasum": "b134f84a8db4c7eda85d73caafcd6757fd71ddbe"
  },
  "_from": "geolib@",
  "_resolved": "https://registry.npmjs.org/geolib/-/geolib-2.0.21.tgz"
}
